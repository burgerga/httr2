% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/req_chunk.R
\name{req_chunk}
\alias{req_chunk}
\alias{chunk_req_perform}
\alias{chunk_next_request}
\title{Chunk a request}
\usage{
req_chunk(req, data, chunk_size, apply_chunk, parse_resp = NULL)

chunk_req_perform(req, progress = TRUE, error_call = current_env())

chunk_next_request(req, i = NULL)
}
\arguments{
\item{req}{A \link{request}.}

\item{data}{The vector to chunk.}

\item{chunk_size}{The size of each chunk.}

\item{apply_chunk}{A function that applies the chunk to the request. It
takes two arguments:
\enumerate{
\item \code{req}: the original request.
\item \code{chunk}: the current data chunk.#'
}}

\item{parse_resp}{A function with one argument \code{resp} that parses the
response.}

\item{progress}{Whether to show a progress bar. Use \code{TRUE} to turn on a basic
progress bar, use a string to give it a name, or see \link{progress_bars} for more
details.}

\item{error_call}{The execution environment of a currently
running function, e.g. \code{caller_env()}. The function will be
mentioned in error messages as the source of the error. See the
\code{call} argument of \code{\link[rlang:abort]{abort()}} for more information.}

\item{i}{The index of the chunk to request.}
}
\value{
For \code{req_chunk()} a list of requests. For \code{chunk_req_perform()} a
list of parsed responses. If this argument is not specified, it will be a
list of responses.
}
\description{
Use \code{req_chunk()} to specify how to request a chunk of data.
Use \code{chunk_req_perform()} to request all chunks.
If you need more control use a combination of \code{\link[=req_perform]{req_perform()}} and
\code{\link[=chunk_next_request]{chunk_next_request()}} to iterate through the chunks yourself.
}
\examples{
req <- request("https://api.restful-api.dev/objects")

ids <- 1:7
chunk_size <- 3

apply_chunk <- function(req, chunk) {
  chunk <- rlang::set_names(chunk, "id")
  req_url_query(req, !!!chunk)
}

parse_resp <- function(resp) {
  parsed <- resp_body_json(resp)
  data.frame(
    id = sapply(parsed, function(x) x$id),
    name = sapply(parsed, function(x) x$name)
  )
}

# in most cases `chunk_req_perform()` should be sufficient
\dontrun{
responses <- chunk_req_perform(
  req,
  chunk_size = 10,
  data = ids,
  apply_chunk = apply_chunk,
  parse_resp = parse_resp
)
}

# in case you need more control of how the requests are performed you can create
# the requests first with `req_chunk()` ...
requests <- req_chunk(
  req,
  chunk_size = 3,
  data = ids,
  apply_chunk = apply_chunk
)

# a simple list of requests
requests

# ... which you can perform with `req_perform()`
\dontrun{
n <- length(requests)
paths <- character(n)
responses <- list()
for (i in seq2(1, n)) {
  paths[[i]] <- tempfile()
  responses[[i]] <- req_perform(requests[[i]], path = paths[[i]])
}
}
}
